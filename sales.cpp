
/***  Compile with:  g++ -o sales.x sales.cpp  ***/

#include <iostream>
#include <utility>
#include <string>
#include <vector>
#include <list>
#include <algorithm>

using namespace std;


Problem 1: 

// We have a fictitious multi-level marketing scheme where a
// member can recruit one or more other members.  At the end
// of the month, member's payout is calculated at 10% of his
// direct sales (items the members sells themselves) and 4%
// of sales generated by his recruits and their recruits.
// Write a function that calculates the monthly compensation
// for all members given the original member.  You can assume
// a member can only be recruited by a single existing member.
// 
// Given the following interface, please implement the
// MemberPayoutUtil.calculatePayout function.
// 
// Received Java code is:
// 
// public interface Member {
//     public double getMonthlySales();
//     private Collection<Member> getRecruitedMembers(); }
//  
// 
// public class MemberPayoutUtil {
//     public static double calculatePayout(Member member) {
//         // Implement me!
//     }
// }
//
// -----------------------
//
// Solution:
//
// Conceptually, the hierarchy can be represented as an n-ary tree
// with the member being computed at the root.  Each node can have
// any number of children, as according to how many members that
// member recruited.
//   The algorithm will therefore be a simple recursive traversal
// down the tree, depth-first, where each member at a lower level
// (closer to the leaves) will pass the info back up to their
// directly recruiting member, with combined sums eventually coming
// back to the root member.  (Interestingly, depending on the height
// of the tree, it is possible that the total payout to members is
// greater than all gross receipts ! )


class Member
{
public:
   double getMonthlySales ()             { return monthly_sales };
   void   setMonthlySales (double sales) { monthly_sales = sales };

   friend double calculatePayout (const Member &member);
   friend double total_sales     (const Member &member);

private:
   double        monthly_sales;
   list <Member> recruits;
}


double
calculatePayout (const Member &member)
{
   double total = 0.10 * member.getMonthlySales ();

   list <Member>::const_iterator memb;

   for (memb = member.recruits.begin();
        memb != member.recruits.end();
        ++memb)
      total += 0.04 * total_sales (*memb);

   return total;
}


double
total_sales (const Member &member)
{
   double total = member.getMonthlySales ();

   list <Member>::const_iterator memb;

   for (memb = member.recruits.begin();
        memb != member.recruits.end();
        ++memb)
      total += total_sales (*memb);

   return total;
}

